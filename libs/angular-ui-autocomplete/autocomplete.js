"use strict"; angular.module("ui.autocomplete", []).directive("uiAutocomplete", ["$timeout", "$exceptionHandler", function (e, t) { function n(e, t) { var n = new RegExp($.ui.autocomplete.escapeRegex(t), "i"); return $.grep(e, function (e) { return n.test($("<div>").html(e.label || e.value || e).text()) }) } var o = $.ui.autocomplete.prototype, i = o._initSource, u = Array.prototype.slice; return $.extend(o, { _initSource: function () { this.options.html && $.isArray(this.options.source) ? this.source = function (e, t) { t(n(this.options.source, e.term)) } : i.call(this) }, _normalize: function (e) { return $.map(e, function (e) { return e && "object" == typeof e ? $.extend({ label: e.label || e.value, value: e.value || e.label }, e) : { label: e + "", value: e } }) }, _renderItemData: function (e, t) { var n = t.groupLabel || t.label; return t.groupLabel ? n = $("<div>").append(n).addClass("ui-menu-group") : this.options.html ? ("object" == typeof n && (n = $(n)), ("object" != typeof n || n.length > 1 || !n.is("a")) && (n = $("<a>").append(n))) : n = $("<a>").text(n), $("<li>").append(n).appendTo(e).data("ui-autocomplete-item", t) }, _resizeMenu: function () { var e = this; setTimeout(function () { var t = e.menu.element, n = t.css("max-height") || 0, o = Math.max(t.width("").outerWidth() + 1, e.element.outerWidth()), i = (e.element.height(), $(window).height() - e.options.outHeight - t.offset().top); i = n && i > n ? n : i, t.css({ width: o, maxHeight: i }) }, 10) } }), { require: "ngModel", link: function (o, i, a, l) { function r(e) { b(v) && (l.$viewValue || 0 === l.$viewValue ? e && e.item && (e.item.label = b(e.item.label) ? $("<div>").append(e.item.label).html() : e.item.label, w(v, e.item)) : f(v), g(l.$viewChangeListeners, function (e) { try { e() } catch (n) { t(n) } })) } function c() { l.$setViewValue(""), l.$render(), r() } function s() { y.options.focusOpen && !m && i.autocomplete("search", "") } function p(e) { return e = b(e) ? e : {}, e.disabled = e.source ? e.disabled : !0, e.appendTo = e.appendTo || i.parents(".ng-view")[0] || i.parents("[ng-view]")[0] || null, e.minLength = e.focusOpen ? 0 : e.minLength, e.outHeight = e.outHeight || 0, e.position = e.position || { my: "left top", at: "left bottom", collision: "flipfit" }, e } function f(e) { if (b(e)) { var t = /^\$/; g(e, function (n, o) { var i = typeof n; t.test(o) || ("number" === i ? e[o] = 0 : "string" === i ? e[o] = "" : "boolean" === i ? e[o] = !1 : b(n) && f(n)) }) } } var m = !1, d = null, h = {}, v = null, g = angular.forEach, b = angular.isObject, w = angular.extend, y = o.$eval(a.uiAutocomplete), x = angular.bind(i, i.val), V = ["close", "destroy", "disable", "enable", "instance", "option", "search", "widget"], H = ["change", "close", "create", "focus", "open", "response", "search", "select"], L = o.$watch(a.ngModel, function (e) { v = e, b(v) && (l.$formatters.push(function (e) { return e.value }), l.$parsers.push(function (e) { return v.value = e, v }), o.$watch(a.ngModel, function (e) { x() !== e.value && (l.$viewValue = e.value, l.$render()) }, !0), l.$pristine = !1, l.$setViewValue(v.value), l.$pristine = !0), e && L() }), M = { open: function (e, t) { m = !0, d = null }, close: function (e, t) { m = !1 }, select: function (t, n) { d = n, e(function () { i.blur() }, 0) }, change: function (e, t) { var n = x(), u = !1; d && d.item && -1 !== n.indexOf(d.item.value) && (n = d.item.value, i.focus(), u = !0), o.$apply(function () { y.options.onlySelectValid && l.$setValidity("onlyselect", u), null === n ? l.$render() : "" === n ? r() : l.$viewValue !== n && (l.$setViewValue(n), l.$render(), r(d)) }) } }; b(y) && (y.methods = {}, y.options = p(y.options), g(H, function (e) { var t = y.options[e]; t = "function" == typeof t ? t : angular.noop, h[e] = function (n, o) { M[e] && M[e](n, o), t(n, o), y.events && "function" == typeof y.events[e] && y.events[e](n, o) } }), g(V, function (e) { y.methods[e] = function () { var t = u.call(arguments); return t.unshift(e), i.autocomplete.apply(i, t) } }), y.methods.filter = n, y.methods.clean = c, i.on("focus", s), i.autocomplete(w({}, y.options, h)), y.widget = i.autocomplete("widget")) } } }]);